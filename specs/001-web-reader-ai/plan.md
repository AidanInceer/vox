# Implementation Plan: Web Reader AI - Desktop Text-to-Speech Browser Integration

**Branch**: `001-web-reader-ai` | **Date**: 2026-01-16 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `/specs/001-web-reader-ai/spec.md`

**Note**: This plan is generated by the `/speckit.plan` command following vox Constitution v1.0.0 and Speckit planning methodology.

## Summary

Build a Windows 11 desktop application that reads any browser tab (Chrome, Edge, Firefox, or any browser) aloud using AI text-to-speech, without requiring the user to switch focus to that tab. Core MVP delivers: (1) Direct browser tab text extraction from non-active tabs, (2) URL/file input capability, (3) Natural speech synthesis with playback controls. Secondary features add tab detection/pointing UI and session management.

## Technical Context

**Language/Version**: Python 3.13  
**Primary Dependencies**: 
- Pillow (image processing for screenshot analysis)
- NumPy/Pandas (data manipulation)
- requests (HTTP fetching for URLs)
- beautifulsoup4 (HTML parsing and text extraction)
- piper-tts (open-source neural text-to-speech synthesis, runs locally, fully offline)
- pywinauto (Windows process/window detection for tab extraction)
- pytest (testing framework with >80% coverage requirement)

**Storage**: File-based (local JSON/SQLite for session persistence, temporary caches)  
**Testing**: pytest with >80% unit test coverage (95%+ for critical paths: text extraction, TTS, tab detection)  
**Code Quality**: ruff (lint + format) with default PEP 8 rules, enforced via pre-commit hooks (format only) and GitHub Actions (format + lint)  
**CI/CD**: GitHub Actions runs on every PR: ruff lint check, pytest suite, coverage gate (≥80% required). No mypy type checking (pytest catches type issues through execution). Branch protection requires all checks pass before merge.  
**Target Platform**: Windows 11 (desktop application, no web server)
**Project Type**: Single desktop application (Python CLI/GUI tool)  
**Performance Goals**: Extract text <3 seconds, generate speech <5 seconds, switch tabs <2 seconds  
**Constraints**: Windows-only (initial), must handle multi-browser tab detection reliably, speech quality must be intelligible  
**Scale/Scope**: Single-user desktop utility (MVP), expandable to batch processing in v1.1+

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

**Compliance Assessment** ✅ **PASS**

1. **Test-First Development** ✅
   - User stories include acceptance scenarios enabling TDD
   - Spec provides testable requirements for tab detection, text extraction, TTS
   - Justification: Constitution mandate applies; no exceptions granted

2. **Text-Based I/O Protocol** ✅
   - Tab content extracted as text (stdout/JSON output)
   - Speech synthesis from text input
   - Error handling to stderr
   - Justification: Aligns with vox mission; naturally supports CLI

3. **Clear API Contracts** ✅
   - Key entities defined: ReadingSession, Page, AudioSettings
   - Function contracts will be documented during Phase 1
   - Justification: SOLID principles required; no conflicts identified

4. **Semantic Versioning** ✅
   - v1.0.0 focuses on core MVP (P1 user stories)
   - v1.1+ can add multi-language, PDF, summarization
   - Justification: Clear scope boundary defined

5. **Code Quality Standards** ✅
   - 80%+ unit test coverage required (95%+ for extraction/TTS modules)
   - SOLID principles enforced during Phase 1 design
   - DRY/KISS applied to text extraction and TTS wrapper code
   - Justification: No deviations; constitution standards apply fully

**No violations or exceptions identified. Plan may proceed to Phase 0.**

## Project Structure

### Documentation (this feature)

```text
specs/001-web-reader-ai/
├── spec.md              # User stories, requirements, success criteria
├── plan.md              # This file (design approach and architecture)
├── research.md          # Phase 0: Tech research outcomes
├── data-model.md        # Phase 1: Entity definitions and schemas
├── contracts/           # Phase 1: API/service contracts
│   ├── browser_tab_detector.md
│   ├── text_extractor.md
│   └── tts_synthesizer.md
├── quickstart.md        # Phase 1: Developer setup and first run
├── checklists/
│   └── requirements.md  # Specification quality validation
└── tasks.md             # Phase 2: Implementation task breakdown
```

### Source Code Structure (repository root)

```text
src/
├── __init__.py
├── main.py              # Application entry point and CLI interface
├── config.py            # Configuration management and constants
│
├── browser/             # Browser tab detection and window management
│   ├── __init__.py
│   ├── detector.py      # Browser process/window detection (Windows API)
│   ├── tab_info.py      # Tab data structures
│   └── accessibility.py # Windows accessibility API wrappers
│
├── extraction/          # Text extraction from pages/tabs
│   ├── __init__.py
│   ├── text_extractor.py   # Main extraction logic
│   ├── html_parser.py      # BeautifulSoup integration
│   ├── dom_walker.py       # DOM traversal and element detection
│   └── content_filter.py   # Section extraction (main/nav/footer)
│
├── tts/                 # Text-to-speech synthesis
│   ├── __init__.py
│   ├── synthesizer.py      # TTS service abstraction
│   ├── piper_provider.py   # Piper neural TTS implementation (local, offline)
│   ├── playback.py         # Audio playback controls
│   └── audio_utils.py      # Audio processing utilities
│
├── session/             # Session persistence and management
│   ├── __init__.py
│   ├── session_manager.py  # Save/load reading sessions
│   ├── storage.py          # SQLite/JSON storage layer
│   └── models.py           # Session data models
│
├── ui/                  # User interface (CLI and/or GUI)
│   ├── __init__.py
│   ├── cli.py          # CLI interface and argument parsing
│   ├── gui.py          # Optional: Tkinter/PyQt GUI
│   └── prompts.py      # User input prompts
│
└── utils/              # Shared utilities
    ├── __init__.py
    ├── logging.py      # Logging configuration
    ├── errors.py       # Custom exception classes
    ├── validators.py   # Input validation functions
    └── cache.py        # Caching utilities

tests/
├── __init__.py
│
├── unit/                # Unit tests (isolated component testing)
│   ├── test_browser_detector.py      # Browser detection logic
│   ├── test_text_extractor.py        # Text extraction accuracy
│   ├── test_tts_synthesizer.py       # TTS service integration
│   ├── test_html_parser.py           # HTML parsing edge cases
│   ├── test_session_manager.py       # Session persistence
│   ├── test_playback_controls.py     # Audio control logic
│   └── test_utils.py                 # Utility functions
│
├── integration/         # Integration tests (component interaction)
│   ├── test_tab_to_speech.py         # Full tab-to-speech pipeline
│   ├── test_url_to_speech.py         # Full URL-to-speech pipeline
│   ├── test_session_resume.py        # Session save/resume workflow
│   ├── test_multiple_browsers.py     # Multi-browser detection
│   └── test_edge_cases.py            # Edge case scenarios
│
├── contract/            # Contract tests (external API boundaries)
│   ├── test_browser_api.py           # Windows API contracts
│   ├── test_tts_api.py               # TTS service contracts
│   └── test_storage_api.py           # Storage layer contracts
│
├── fixtures/            # Test data and fixtures
│   ├── sample_pages/    # HTML samples for extraction testing
│   ├── mock_data.py     # Mock objects and factories
│   └── conftest.py      # Pytest configuration
│
└── performance/         # Performance and load testing
    ├── test_extraction_speed.py      # Text extraction benchmarks
    └── test_memory_usage.py          # Memory profile tests

docs/
├── architecture.md      # High-level architecture diagrams
├── api_reference.md     # API documentation
└── contributing.md      # Development guidelines

pyproject.toml           # Project metadata and dependencies
pytest.ini              # Pytest configuration
README.md               # Project overview
```

**Structure Decision**: Single desktop application (Python 3.13) with modular architecture. Browser detection and text extraction separated from TTS to enable independent testing and future multi-provider support. Session management isolated in dedicated module for clear persistence logic. Tests organized by type (unit/integration/contract) following Constitution test-first mandate and >80% coverage requirement.

## Complexity Tracking

**No Constitution violations identified.** All requirements align with vox Constitution v1.0.0:
- Test-first approach: Acceptance scenarios enable TDD for every component
- Code quality: SOLID + DRY/KISS applied to modular structure above
- Coverage: 80%+ unit tests required; 95%+ for critical paths (extraction/TTS)
- Scope: Clear MVP (P1 stories) vs. future enhancements (P2/P3 stories)

| Violation | Why Needed | Simpler Alternative Rejected Because |
|-----------|------------|-------------------------------------|
| [e.g., 4th project] | [current need] | [why 3 projects insufficient] |
| [e.g., Repository pattern] | [specific problem] | [why direct DB access insufficient] |

## Development Phases

Each phase includes implementation followed by **mandatory refactoring checkpoint** to maintain code quality per vox Constitution v1.1.0:

**Phase 0: Research & Planning**
- Clarify unknowns from specification
- Research technology choices (Piper TTS, pywinauto, BeautifulSoup, etc.)
- Document findings in research.md
- *Refactoring Checkpoint*: Review research recommendations for consistency

**Phase 1: Design & Contracts**
- Extract data model entities (ReadingSession, Page, AudioSettings)
- Generate API contracts for key services (browser detection, text extraction, TTS)
- Create quickstart.md for developer setup
- *Refactoring Checkpoint*: Format documentation, verify contract consistency

**Phase 2: Foundation Implementation**
- Implement Phase 1 source modules (config.py, custom errors, logging utilities)
- Write unit tests for all foundation modules (≥80% coverage required)
- Verify all tests pass and coverage gates met
- *Refactoring Checkpoint*: **ruff check --fix**, **pytest**, ensure 80%+ coverage maintained

**Phase 3: Core Feature - User Story 1 (Quick Page Reading)**
- Implement browser detection (detector.py, accessibility.py)
- Implement text extraction (html_parser.py, dom_walker.py, text_extractor.py)
- Implement TTS synthesis (piper_provider.py, synthesizer.py, playback.py)
- Implement CLI interface (main.py)
- Write unit and integration tests (≥80% coverage, 95%+ for critical paths)
- *Refactoring Checkpoint*: **ruff check --fix**, **ruff format**, **pytest --cov**, verify coverage gates and zero lint errors

**Phase 4: URL/File Input - User Story 2**
- Implement URL fetcher (url_fetcher.py)
- Implement file loader (file_loader.py)
- Implement content filter (content_filter.py)
- Update text extractor with new source methods
- Update CLI with URL/file arguments
- Write unit and integration tests (≥80% coverage)
- *Refactoring Checkpoint*: **ruff check --fix**, **ruff format**, **pytest --cov**, verify coverage gates and zero lint errors

**Phase 5: Tab Detection UI - User Story 3**
- Implement advanced tab detection across multiple browsers
- Implement tab picker UI (CLI or GUI)
- Write contract tests for OS API boundaries
- Write integration tests for full tab detection flow
- *Refactoring Checkpoint*: **ruff check --fix**, **ruff format**, **pytest --cov**, verify coverage gates and zero lint errors

**Phase 6: Playback Controls - User Story 4**
- Implement pause/resume/skip controls
- Implement speed/volume adjustment
- Implement section navigation
- Write unit and integration tests for all controls
- *Refactoring Checkpoint*: **ruff check --fix**, **ruff format**, **pytest --cov**, verify coverage gates and zero lint errors

**Phase 7: Session Persistence - User Story 5**
- Implement session manager (save/resume logic)
- Implement storage layer (JSON/SQLite)
- Write tests for session lifecycle
- *Refactoring Checkpoint*: **ruff check --fix**, **ruff format**, **pytest --cov**, verify coverage gates and zero lint errors

**Phase 8: Configuration & Edge Cases - User Story 6**
- Implement settings/configuration module
- Implement content filter configuration
- Handle edge cases (no text, JS-rendered content, network errors, PDFs, multi-language)
- Write tests for all edge cases
- *Refactoring Checkpoint*: **ruff check --fix**, **ruff format**, **pytest --cov**, verify final 80%+ coverage, zero lint errors

**Refactoring Checkpoint Details (Between All Phases)**:
1. **Code Formatting**: Run `ruff format .` to normalize all code to project style (120 char lines, standard conventions)
2. **Code Linting**: Run `ruff check --fix` to auto-fix fixable violations (import ordering, unused variables, etc.)
3. **Manual Code Review**: Check for SOLID violations, DRY/KISS breaches, unclear variable names
4. **Test Coverage**: Run `pytest tests/ --cov=src --cov-report=term-missing` and verify ≥80% coverage maintained
5. **Documentation**: Update docstrings, inline comments, and README as needed
6. **Commit**: Stage and commit all changes with message "Phase X: Refactor (format, lint, coverage check)"

**Rationale**: Regular refactoring between phases prevents technical debt accumulation, maintains consistency with vox Constitution standards, and ensures code quality gates are enforced incrementally rather than addressed as cleanup at the end.
